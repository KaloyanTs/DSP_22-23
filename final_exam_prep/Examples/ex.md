###Да се реализира функция, която слива два едносвързани списъка от числа, подредени в нарастващ ред, така че резултатът да съдържа всички числа отново в нарастващ ред.

```
void merge(Node *&l1, Node *&l2)
{
    if (!l1)
    {
        l1 = l2;
        l2 = nullptr;
        return;
    }
    if (!l2)
        return;
    Node *i1 = l1, *i2 = l2;
    Node *t = (l1->val < l2->val ? l1 : l2);
    l1 = t;
    l2 = nullptr;
    if (i1->val < i2->val)
        i1 = i1->next;
    else
        i2 = i2->next;
    while (i1 && i2)
    {
        if (i1->val < i2->val)
        {
            t = t->next = i1;
            i1 = i1->next;
        }
        else
        {
            t = t->next = i2;
            i2 = i2->next;
        }
    }
    while (i1)
    {
        t = t->next = i1->next;
        i1 = i1->next;
    }
    while (i2)
    {
        t = t->next = i2->next;
        i2 = i2->next;
    }
}
```

###Кое от следните твърдения за алгоритми над графи е вярно (с n е означен броят на върховете):
######Обхождането на граф в дълбочина винаги е по-бързо от обхождането му в ширина.
######Обхождането на граф в ширина винаги е по-бързо от обхождането на граф в дълбочина.
######Обхождането на граф в ширина заема в най-лошия случай памет, линейна по n
######Обхождането на граф в дълбочина отнема в най-лошия случай памет, линейна по n
###Да се посочат едно предимство и един недостатък на представянето на граф чрез матрица на съседство
<span style="color:lightblue"> предимство: добавяне и премахване на ребро за константно време
недостатък: премиахване и добавяне на нов връх са с квадратична сложност </span>
###Да се открият и поправят грешките в следната реализация на търсене на елемент в двоично дърво за търсене:
```
void search(T const& x) {
  P pos = rootPosition();
  while (*pos != x) {
    if (pos < x) pos = pos.left();
    if (pos >= x) pos = pos.right();
  }
  return *pos;
}
```

```
P search(T const& x) {
  P pos = rootPosition();
  while (pos.valid() && *pos != x) {
    if (pos < x) pos = pos.left();
    if (pos >= x) pos = pos.right();
  }
  return pos;
}
```

###Да се даде пример за физическо представяне на структурата от данни стек.
<span style="color:lightblue">статичен масив и индекс на върха на стека</span>
###Да се опише в какъв ред ще бъдат изведени елементите на следното дървото при обхождане дясно-ляво-корен.Пример за двоично дърво
<span style="color:lightblue">4 6 2 3 8 1</span>
###Кое от следните твърдения за балансирани двоични дървета е вярно?
######Ако в дадено двоично дърво броят на елементите в лявото и дясното му поддърво се различава с най-много 1, то е идеално балансирано.
######Има идеално балансирани дървета, които не са балансирани.
######Не всяко двоично дърво е балансирано, но всяко двоично наредено дърво е балансирано.
<span style="color:lightblue">
За всяко балансирано дърво височината на лявото и дясното поддърво се различават с не повече от 1.
</span>
###Да се предложи примерна йерархия от класове, която позволява реализацията на хетерогенен списък от речници, всеки от които може да е с различна реализация: сортиран масив, AVL дърво или хеш таблица.
```
class Dictionary;

class AVLTree;
class SortedArray;
class HashTable;
class AVLDictionary:public Dictionary,public AVLTree;
class HashDictionary:public Dictionary, public HashTable;
class ArrayDictionary:public Dictionary, publc SortedArray;
class DictList
{
  Dictionary ** list;
  size_t size;
}
```

###Коя от следните сложности е най-висока?

<span style="color:lightblue">Експоненциална</span>
######Кубична
######Логаритмична
######Константна