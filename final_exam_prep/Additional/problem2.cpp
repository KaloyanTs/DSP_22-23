// В града Имеяд могат да бъдат наблюдавани интересни явления. Целият град е съставен от множество обекти, които могат да бъдат посетени
//(мислете си за кино, мол, бръснар). За съжаление, при всяко преминаване от един обект до друг се заплаща сурова цена – първата буква от името на човек!
// За всеки един обект знаем до кои други обекти можем да стигнем и с коя специфична буква става това; съответно този преход може да направи само човек,
// чието текущо (може би вече съкратено) име започва с тази буква. Например ако знаем, че от банка се стига до мол с буква ‘а’,
// то ana ще може да премине, но liana няма да може.

// Програмата ви ще получи информация за обектите в града и име на човек (поредица от малки латински букви).
// След това тя трябва да отговори кои са всички най-отдалечени обекти до които може да достигне човекът.

// Информацията за обектите ще се съхранява във файл, който ще се подаде на програмата. Първият ред в него съдържа името на обекта,
// който се намира на входа на града (всички хора тръгват от него). Всички останали редове описват преходите между обектите. Те са в следния формат:

//<начало> <край> <буква>
// Под най-отдалечени обекти разбираме тези, които могат да се достигнат с най-големия възможен брой преходи, тръгвайки от началния обект.
// Те ще варират в зависимост от името на човека, който е дошъл в града. Веднъж достигнал тези обекти,
// той/тя или ще е изчерпал всички букви в името си, или няма да може да отиде в никой друг обект с оставащите букви.

// Уточнения: 	* На входа на програмата ще се подадат път до файл описващ обекти и име на човек;
//		* Буквите в преходите и имената са само малки латински;
//		* Не са възможни зацикляния измежду обектите (в графа няма цикли);
//		* Ако от обект A можем да стигнем до обект B с буква 'c', то не е задължително вярно, че от B можем да стигнем до A със 'c';
//		* След всеки преход от едно място до друго, името, което сте получили като вход се намалява с буквата, която сте заплатили.
//			Ако от A отиваме в B с ‘a’,то името ani би станало – ni.

#include <iostream>
#include <unordered_map>
#include <string>
#include <fstream>
#include <vector>

struct City
{
    using AdjList = std::unordered_map<std::string, char>;
    using AdjMatrix = std::unordered_map<std::string, AdjList>;

    AdjMatrix data;
    std::string start;

    City(std::ifstream &ifs)
    {
        std::string from, to;
        char letter;
        ifs >> start;
        while (!ifs.eof())
        {
            ifs >> from >> to >> letter;
            data[from][to] = letter;
        }
    }
    void rec(const std::string &from, std::vector<std::string> &res, size_t &bestDepth, size_t depth, const char *name)
    {
        if (!data.count(from) || !*name)
        {
            if (depth >= bestDepth)
            {
                if (depth > bestDepth)
                {
                    bestDepth = depth;
                    res.clear();
                }
                res.push_back(from);
            }
            return;
        }
        for (std::pair<const std::string, char> &path : data[from])
        {
            if (path.second == *name)
                rec(path.first, res, bestDepth, depth + 1, name + 1);
        }
    }
    std::vector<std::string> longestWalk(const std::string &name)
    {
        std::vector<std::string> res;
        size_t bestDepth = 0;
        rec(start, res, bestDepth, 0, name.c_str());
        return res;
    }
};

int main()
{
    std::ifstream ifs("test.txt");
    if (!ifs.is_open())
        throw std::exception();
    City c(ifs);
    for (std::string &s : c.longestWalk("anika"))
        std::cout << s << ' ';
    std::cout << '\n';
    return 0;
}